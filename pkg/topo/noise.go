package topo

import (
	"willbeason/worldproc/pkg/fixed"
	"willbeason/worldproc/pkg/noise"
	"willbeason/worldproc/pkg/transforms"
)

// NoiseTopography represents a topography generated by a noise.Value.
//
// Notice all of the data in here are held as structs, not pointers to structs.
// The dereferencing time for these is significant compared to the actual
// calculations. Measured 4x faster to directly embed these structs.
type NoiseTopography struct {
	Noise     noise.Value
	Scales    transforms.Scales
	Offsets   transforms.Offsets
	Rotations transforms.Rotations

	Depth int
}

// HeightLinear calculates the height of the topography at the passed values.
func (t *NoiseTopography) HeightLinear(x, y fixed.F16) fixed.F32 {
	height := fixed.Zero32
	for depth := 0; depth < t.Depth; depth++ {
		// Scale
		xt, yt := x.Times(t.Scales[depth].Frequency).F16(), y.Times(t.Scales[depth].Frequency).F16()
		// offset
		xt, yt = xt+t.Offsets[depth].X, yt+t.Offsets[depth].Y
		// Rotate and scale.
		// Measured faster to inline rotation.
		height += t.Noise.Linear((xt.Times(t.Rotations[depth].Cos) + yt.Times(t.Rotations[depth].Sin)).F16(), (yt.Times(t.Rotations[depth].Cos) - xt.Times(t.Rotations[depth].Sin)).F16()).F16().Times(t.Scales[depth].Amplitude)
	}

	return height
}

// HeightNearest calculates the height of the topography at the passed values.
func (t *NoiseTopography) HeightNearest(x, y fixed.F16) fixed.F32 {
	height := fixed.Zero32
	for depth := 0; depth < t.Depth; depth++ {
		// Scale
		xt, yt := x.Times(t.Scales[depth].Frequency).F16(), y.Times(t.Scales[depth].Frequency).F16()
		// offset
		xt, yt = xt+t.Offsets[depth].X, yt+t.Offsets[depth].Y
		// Rotate and scale.
		// Measured faster to inline rotation.
		height += t.Noise.Nearest((xt.Times(t.Rotations[depth].Cos) + yt.Times(t.Rotations[depth].Sin)).F16(), (yt.Times(t.Rotations[depth].Cos) - xt.Times(t.Rotations[depth].Sin)).F16()).Times(t.Scales[depth].Amplitude)
	}

	return height
}
